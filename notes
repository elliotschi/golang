bin: contains executable files

pkg: contains compiled files

src: contains package source files

25 keywords

:= used inside functions => you don't need to put a declaration.

otherwise you need var, const

datatypes: boolean, numeric types: int8 int32, strings("" or ``) 
- can access strings by variableName[0]

- storing things in bytes

- there is one error type, but there is also a package called errors that you can import

- group definitions import (), const(), var()

arrays: 
var arr[n]type

n: length of array : since length is included in the declaration, we cannot change the size of arrays
type: the type of its elements

- want to use slice to get a copy of an array

c := [...]int{4,5,6} - using this syntax we read all the elements and finds the length

nestedArray := [2][4]int{[4]int{1,2,3,4}, [4]int{5,6,7,8}}

more concise way of doing this is 

nestedArray := [2][4]int{{1,2,3,4}, {5,6,7,8}}

slice: slice points to an underlying array where the length is not required

array[i:j] is a copy from i to j

array[:n] is the same as array[0:n]
array[n:] is the same as array[n:len(array)]
array[:] slices the whole array

slice is a reference type, so any changes will change the variables pointing to the same slice or array.

MAPS: objects

map[keyType]valueType for definition
- specify the type for the keys and the value

gets & sets

ie: var numbers map[string] int

or 

numbers := make(map[string]int)

- maps are disorderly, no fixed length, but it has a len property

use delete to delete and element
delete(map, key)

-make vs new:

make does memory allocation for built in models, and new is for types' memory allocation

- new returns pointer

IF - doesn't need parens in Go.
- it can have one init statement before the conitional : the variables defined in in there can be used in the block of the if statement

ie: 
if x: computedValue(); x > 10 {
}

this will call the function computedValue and then see if x is > 10

else if and else are the same

GOTO - keyword: goto reroutes the control flow to a previously defined label

labels are anything that ends with ":"

for expression1; expression2; exression3

we can omit expressions if we want
for is identical to while

break & continue both exist

switch syntax:

switch sExpr {
  case expr1:
    some instructions
}